
=== Visual Galite Forms

The aim of Galite is to enable you to create applications.
An application is made up of forms. A *form* is a set of *pages* consisting of *blocks*.
A *block* is nothing else than a table which is divided into columns (vertical) and rows (horizontal).
A row is made up of *fields*, and each *field* contains a data value at the intersection of a row and a column that can be of different *Types*.
By the end of this chapter, you will learn how to create a form, but before, you need to learn how to create a field and how to form blocks.

==== Creating Form Fields

In Galite, fields are containers in which you can define different types of data.
To define a field you can call one of the 4 functions `mustFill()`, `visit()`, `skipped()` or `hidden()`. You can pass the domain and the position of the field in the block as arguments.


*Syntax*
[source,kotlin]
----
val fieldName = mustFill(FieldDomain, [FieldPosition]) {
    FieldBody
}

|

val fieldName = visit(FieldDomain, [FieldPosition]) {
    FieldBody
}

|

val fieldName = skipped(FieldDomain, [FieldPosition]) {
    FieldBody
}

|

val fieldName = hidden(FieldDomain, [FieldPosition]) {
    FieldBody
}

FieldBody         : [FieldLabel] [FieldHelp] [FieldAlignment]
                    [FieldDropList]     [FieldOptions]    [FieldColumns] 
                    [FieldCommands] [FieldTriggers]
----

===== Field Access Modifiers
An access modifier determines the way the application user will have to handle each field in a form as well as the field accessibility. There are 4 sorts of access modifier:

*Syntax:*
[source,kotlin]
----
AccessModifier:   mustFill()
                  |
                  visit()
                  |
                  skipped()
                  |
                  hidden()
----

 * mustFill : As indicated, a MUSTFILL field has to be filled by the user.
 * visit    : A VISIT field is a field which the user can fill if he wants to.
 * skipped  : A SKIPPED field is a field which is displayed on the form but which the user can not overwrite. A field is skipped if the user needs to know the information written in it.
 * hidden   : A HIDDEN field that is not displayed on the form as the information it provides is of no importance for the user, this kind of fields is usually used for database table join operations or for ID fields.

As the user moves from a field to another when filling the form, the current field is always colored in red.

*Example*

[source,kotlin]
----
val password = mustFill(domain = STRING(20), position = at(2, 1)) {
  ...
}
   
val id = hidden(domain = INT(20)) {
  ...
}
----

===== Field Position

This entry defines the position of the field in the current block. HIDDEN fields does not have positions, and in multiple block (Defined in the  Blocks creation Section of this document) you may use the NO DETAIL Block option to pass positioning fields.
There are two possibilities to define the field position.

 * *Absolute Position With the function `at()`*

You can define it according to one integer or more: ::

 ** at(row)
 ** at(row , column)
 ** at(row, column..multifield)

*Syntax:*
[source,kotlin]
----
FieldPosition : at(row: Int  [,column: Int])
                |
                at(rowRange: IntRange,  [,column: Int])
                |
                at(row: Int  [,columnRange: IntRange])
                |
                at(rowRange: IntRange,  [,columnRange: IntRange])
                |
                follow(otherField)
----

*Example*

[source,kotlin]
----
val name = visit(domain = STRING(20), position = at(1, 1..4)) {
  ...
}
----
The first integer indicates the row number while the second defines the column.
In fact, Galite automatically divides up the window in rows and columns when setting up a form. +
 When defining the width of a column, thus,
it always adopts the width of the longest field. Since the form wide is not unlimited,
you can put a long field in two or more columns in order to spare place as it is the case in the example above.

 * *Relative Position With follow*

You can also make use of the following structure : `follow(otherField)`

*Example*

[source,kotlin]
----
val age = visit(domain = INT(3), position = follow(name)) {
  ...
}
----
If you declare a field with the follow function, it means that this field will be placed directly next to the first field defined by the follow property (field "Name") on the same row. The two fields will then form one single column.

===== Field label

The field label is optional, you declare it with the label property inside the field body, the syntax is the following :

*Syntax*
[source,kotlin]
----
FieldLabel : label = "NAME OF THE FIELD"
----

If you don't want your field to have a label, you can set the property label to empty.

*Example*
[source,kotlin]
----
val secondName = visit(domain = STRING(20), position = at(1, 1)) {
    label = "The second Name"
    ...
}
----

===== Field Help Text

this property is used to insert an explanation text for the application user in order to help him filling in the form. This Help text will then be displayed when the user places the mouse on the field.

*Syntax:*

[source,kotlin]
----
HelpText:   help = "HELP TEXT"
----
*Example*

[source,kotlin]
----
val lesson = visit(domain = STRING(20), position = at(1, 1)) {
    label = "lesson"
    help =  "The lesson you would like to attend"
    ...
}
----

===== Field Types

The field type is a required entry, you may enter a predefined field type :

*Example*
[source,kotlin]
----
val name = visit(domain = STRING(20), position = at(1, 1)) {
    ...
}

val age = visit(domain = INT(3), position = at(1, 2)) {
    ...
}
----

You can also use self defined field types that you have previously defined in the type definition section of your form.

*Example*
[source,kotlin]
----
val day = mustFill(domain = Days, position = at(1, 1)) {
    label = "day"
    help = "The day"
}
----

In this example, Days is a type you should have defined previously using standard types, `Code` types and `SELECT` command ...

===== Field Alignment

This property is used to define the localization of the field's content inside the field. There are three types of alignment.

* FieldAlignment.RIGHT the value is displayed at the right inside the field
* FieldAlignment.LEFT the value is displayed at the left inside the field
* FieldAlignment.CENTER the value is centered in the field

*Example*
[source,kotlin]
----
val name = visit(domain = STRING(20), position = at(1, 1)) {
    label = "name"
    align = FieldAlignment.LEFT
}
----

=====  Field Drop files

This command is used to make a field accept to drop files into it, meaning you can drag files and drop them in your field.

*Syntax:*
[source,kotlin]
----
DroppableDefinition : "droppable" ExtensionList
ExtentionList       : extension : String [,ExtenstionList]
----
*Example*
[source,kotlin]
----
val cv = visit(domain = STRING(20), position = at(4, 1)) {
    label = "Cv"
    help = "The user curriculum vitae"
    columns(u.cv)
    droppable("pdf")
    trigger(ACTION) {
      FileHandler.fileHandler!!.openFile(form.model.getDisplay()!!, object : FileHandler.FileFilter {
        override fun accept(pathname: File?): Boolean {
          return (pathname!!.isDirectory
                  || pathname.name.toLowerCase().endsWith(".pdf"))
        }

        override val description: String
          get() = "PDF"
      })
    }
}
----
In this example, you can drag pdf files and drop them in the field named "cv".

===== Field Options

In this part of the field definition, you can use one or more option from the 9 options available for fields in Galite, here is the a list of these field options defined under the class FieldOption and that you can use them by declaring the function options().

 * NOECHO               : If this option is used, characters typed in the field will not be displayed and a star(*) will be displayed instead, this option is useful for password fields.
 * NOEDIT               : This option makes it impossible to change the data of the field or to overwrite it.
 * SORTABLE             : This option adds two opposed arrows icons(up and down) just before the field, clicking on the icon changes the way data are sorted in the field, you can click the icon three times to have ascending sort, descending sort and default sort,
 * TRANSIENT            : This option make the field transient, meaning that the system can no trail it, if a transaction  calls this field and then this transaction is aborted, the field will not be able to backup or roll-back to its original value, besides this option makes changes ignored for this field.
 * NO DELETE ON UPDATE  : If the field is a lookup is a column of a lookup table, using this option prevent the system to clear the field when inserting new rows or updating rows.
 * NO DETAIL            : If the block is in detailed, using this option on a field make it invisible in the detail.
 * NO CHART             : If the block is multiple, using this option on a field exclude it from the chart.
 * QUERY UPPER          : Whatever the string you input, this option will make Galite transform it to capital letters.
 * QUERY LOWER          : the opposite of the previous option it transform strings to lower case.

*Example*
[source,kotlin]
----
val password = mustFill(domain = STRING(20), position = at(2, 1)) {
    label = "password"
    help = "The user password"
    options(FieldOption.NOECHO)
}
----

===== Field Columns

The columns method option is used to establish a connection between a certain column in the database with the field.Once such connection established, the field will have a direct access to the database column allowing insertions, modification ...+
You may enter this option in order to specify which table and which column the field refers. +
The same field can refer to more than one column.
 You can also use the key method option to specify a key column in the database or the nullable method option to specify an outer joint.+
Two more option are available with the `columns` function, the index and the priority options.

*Syntax:*

[source,kotlin]
----
columns(ColumnList) {
    ColumnsBody
}

ColumnsBody  : [ColumnIndex] [ColumnPriority]

ColumnList   : Column  [, Column ]
Column       : ["KEY (QualifiedName)"] ["NULLABLE (QualifiedName)"]
----
*Example*

[source,kotlin]
----
 val id = hidden(domain = INT(20)) {
    label = "id"
    help = "The user id"
    columns(u.id)
}
----

NOTE: that a field can be connected to more than one table and column. In this case, the statement you will type will be:

*Example*

[source,kotlin]
----
val id = hidden(domain = INT(20)) {
    label = "id"
    help = "The user id"
    columns(I.NumInvoice, ID.Invoice)
}
----
In this example, `I` is the invoices table and `ID` is the invoice details table and they have an outer join connection throw columns NumInvoice and Invoice.

 * *Indexes*

This option is used to define a value in the database which is to remain unique so that it can not appear anymore in another field of the same column. you need to use the index method to declare an index in Galite.

Let’s sum up with the following syntax:

*Syntax:*

[source,kotlin]
----
ColumnIndex : "val i = index(message : String)"
----

If two or more fields are given the same index value, it means that two similar combinations of these field values will not be accepted.

For example, two different lessons cannot be given in the same room. In this case, the three fields, namely the fields "professor", "time" and "lesson" are to be attributed the same index. Thus, at least one of the three values needs to be changed so that the combination can be accepted by the machine.

*Example*

[source,kotlin]
----
val i = index(message = "this should be unique")

val lesson = mustFill(domain = INT(11), position = at(1, 1)) {
    label = "Lesson"
    help = "The lesson you have to attend to"
    column(LEC.Lesson)  {
        index = i
    }
}

val lecturer = mustFill(domain = INT(11), position = at(2, 1)) {
    label = "Lecturer"
    column(LES.Lecturer)  {
        index = i
    }
}

val time = mustFill(domain = STRING(20), position = at(3, 1)) {
    label = "Time"
    help = "The lesson you have to attend to"
    column(LES.Time)  {
        index = i
    }
}
----

However, this example would implicate a professor can give two different lessons at the same time. In order to avoid such errors, you can attribute one field two or more indexes. So you can associate the two fields "professor" and "time" together. Thus, you will have:

*Example*

[source,kotlin]
----
val lessonIndex = index("Lesson should be unique")
val timeIndex = index("Time should be unique")

mustFill(domain = LONG(20)) {
  label = "Lesson"
  help = "The lesson you have to attend to"
  column(LEC.Lesson) {
    index = lessonIndex
  }
}

visit(domain = LONG(10)) {
  label = "Lecturer"
  column(T.Lecturer) {
    index = lessonIndex + timeIndex
  }
}

mustFill(domain = STRING(20)) {
  label = "Time"
  column(LEC.Time) {
    index = timeIndex
  }
}
----
In this case, notice that the "Lecturer" field has been associated with two indexes: lessonIndex and timeIndex.

The index value is ascendant. When attributing an index value to a field combination, you shall always take the value nexting that you have taken the last.

 * *Priority*

*Syntax:*

[source,kotlin]
----
ColumnPriority:   "priority = Integer"
----
This option is used in order to define the column order within a list when this list is displayed. A priority is always followed by an integer according to the structure given above. The column with the biggest priority value will appear on the extreme left side of the table and the one with the least value will be on the extreme right side.

We shall notice that negative values are also permitted in this option. However, the minus sign ("-") standing before the number does not have any influence over its value but simply indicates the way all the information will be sorted out within a column. Actually, the different fields are always sorted in the ascending way, i.e from A to Z in case of an alphabetical text and from 1 to x+1 for numbers. Now, if the integer is preceded by a minus, the column content will be sorted in the other way round.

*Example*

[source,kotlin]
----
val i = index(message = "this should be unique")

val surname = mustFill(domain = STRING(20), position = at(1, 1)) {
    label = "Surname"
    column(User.Surname)  {
        priority = 3
    }
}
----

If columns "Surname", "Name" and "Date of Birth" are
respectively given the priorities 3,4 and 1, "Name" will come
first and will be followed by "Surname" and "Date of Birth".
The same order applies with the values 3, -4 and 1, with the only
difference that the names will be sorted out from Z to A.

Moreover, two columns with the same priority will be displayed according to the same order in which the user has listed them.

===== Field Commands

Once you have defined the columns , you may define the field commands.

*Syntax:*

[source,kotlin]
----
command(item : Actor, [AccessMode]) {
  CommandBody
}

CommandBody     :   CommandAction

CommandAction   :   KotlinCode

AccessMode      : "arrayOf(" vararg ListOfModes.. ")" |  vararg ListOfModes..
----

===== Standard Field Command

The command can be a Galite predefined command or you can make new Actors and commands you can use in the field command definition.

Example:
[source,kotlin]
----
command(item = clear, Mode.UPDATE, Mode.INSERT, Mode.QUERY) {
  ...
}

val clear = actor()
----

===== Field Command using Modes

All the previous command definition ways can be preceded by one mode or more. There are three sorts of mode which are to be sorted according to the following hierarchy:

 * QUERY to start an inquiry within the database
 * INSERT to create a new row in the database
 * UPDATE to enter new information within a row

*Example*

[source,kotlin]
----
command(item = insertMode, Mode.UPDATE, Mode.QUERY) {
  ...
}
----

If you have entered a mode for the `command`, it means this command can only be invoked if the block is in the mode you have determined.

===== Field Access modifiers using Modes

This method type is used to change the access to the field using the block Mode. In fact the access is not changed directly but the higher access possible is set to the indicated access.

We have 12 method allow us to change the visibility of our field :

 * onQueryHidden()              : in mode Query set field to Hidden access
 * onQuerySkipped()             : in mode Query set field to Skipped access
 * onQueryVisit()               : in mode Query set field to Visit access
 * onQueryMustFill()            : in mode Query set field to MustFill access
 * onInsertHidden()             : in mode Insert set field to Hidden access
 * onInsertSkipped()            : in mode Insert set field to Skipped access
 * onInsertVisit()              : in mode Insert set field to Visit access
 * onInsertMustFill()           : in mode Insert set field to MustFill access
 * onUpdateHidden()             : in mode Update set field to Hidden access
 * onUpdateSkipped()            : in mode Update set field to Skipped access
 * onUpdateVisit()              : in mode Update set field to Visit access
 * onUpdateMustFill()           : in mode Update set field to MustFill access

*Example*
[source,kotlin]
----
 val file = visit(domain = STRING(25), position = at(3, 1)) {
      label = "test"
      help = "The test"
      onQueryHidden()
      onInsertHidden()
}
----
In this example, we have determined that the field will be invisible
if the block is in the `QUERY` or the `INSERT` mode.

===== Field Triggers

Triggers are events that you can use to execute actions when they occur, there are field triggers, block triggers and form triggers that you can use following this syntax :

*Syntax*
[source,kotlin]
----
Trigger      : "trigger (" EventList ")" TriggerAction

EventList    : Event [,EventList]

TrigerAction : {KOTLIN code}
----

Field Triggers are events that concern the fields behavior, here is a list of all Galite field triggers available :

  * PREFLD     : is executed upon entry of field

  * POSTFLD    : is executed upon exit of field

  * POSTCHG    : is executed on field content change

  * PREVAL     : is executed before validating any new entry

  * VALFLD     : is executed after field change and validation

  * VALIDATE   : this is the same trigger as VALFLD

  * DEFAULT    : Defines the default value of the field to be set if the setDefault() method is called (this method is automatically called when the user choose the insert command)

  * FORMAT     : Not defined actually

  * ACCESS     : ACCESS is a special trigger that defines how a field can be accessed. This trigger must return one of these values ACS_SKIPPED, ACS_HIDDEN, ACS_VISIT or ACS_MUSTFILL.

  * VALUE      : equates the value of two fields

  * AUTOLEAVE  : must return a boolean value, if "true" the cursor will move to the next field

  * PREINS     : is executed before inserting a row of the database

  * PREUPD     : is executed before updating a row of the database

  * PREDEL     : is executed before deleting a row of the database

  * POSTINS    : is executed after inserting a row of the database

  * POSTUPD    : is executed after updating a row of the database


*Examples*
[source,kotlin]
----
val age = visit(domain = INT(3), position = follow(name)) {
    label = "age"

    trigger(POSTCHG) {
      name.value = "userName"
    }
  }
----

in the example above we will assign the value "userName" to the name field each time we change the value of the age field.

----
val password = mustFill(domain = STRING(20), position = at(2, 1)) {
    label = "password"

    trigger(ACCESS) {
      if (name.value == "hidden") {
        Access.HIDDEN
      } else {
        Access.SKIPPED
      }
    }
}
----

==== Creating Form Blocks

As you already know, a form is composed of blocks. A block is a set of data which are stocked in the database and shown on a form. A block is created in order to either view the content of a database, to insert new data in the database or to update existing data in the database.
To create a block you need first to create a class that extend from Block class here we can specify the name, the buffer size and the rows number of the block as parameter, in second part you need to use insertBlock method that allow you to add the block to the form.

*Syntax*
[source,kotlin]
----
class Block: Block(blockName : String, buffer: Int, rows: Int) {
    BlockBody
}

BlockBody       : [blockBoder] [blockAlignement] [blockHelp]
                  [blockOptions] [blockTables]
                  [blocIndices] [blockCommands] [blockTriggers] blockFields
                  [blockContextFooter]
----

===== Block Types

There are actually two types of blocks in Galite, the only difference between them in the definition syntax is the buffer Integer.

 * single blocks

A single block is a block in which only one single row of a database table is displayed on the form. Each time, the computer will memorize only one entire row and a certain quantity of ID numbers through which it will retrieve another rows from the database if you want to view them.

*Example*
[source,kotlin]
----
class BlockCommand : Block("Commands", 1, 5) {
  ...
}

// usage:

val BlockCommand = page.insertBlock(BlockCommand()) {
...
}
----
The first integer indicates the block type. In case of a single block, the first integer will always be 1. The second integer indicates the maximal number of the automatically memorized IDs.

* Multiple Blocks

A multiple block is a block in which more than one row are displayed on the form. These rows are retrieved all at once from the database and are memorized by the computer. Actually, you can define the number of the displayed rows which can be less than this of the memorized rows. In this case, there will be no need anymore to retrieve the hidden rows from the database when you want to view them.

*Example*
[source,kotlin]
----
class BlockCommand : Block("Commands", 10, 5) {
  ...
}
----
The first integer indicates the number of rows to be automatically memorized while the second defines the number of displayed rows. Notice the first integer value must always be greater than 1.

===== Block Names

The example bellow show how to create a block, you need to specify the block title as parameter in the Block class.

*Example*
[source,kotlin]
----
class Degree : Block("Degree Block", 10, 5)
----

===== Block Border

You can insert the optional border statement that defines the Block's frame type into the init block. Besides, the Title of the block will appear only if the Block's Border type has been specified. There are actually four Border options defined into Border enumeration class :

* Border.LINE to frame the block with lines.
* Border.RAISED  to enhance a block by setting it on the foreground.
* Border.LOWERED to put it at the background.
* Border.ETCHED  to carve a frame in the form.

*Example*
[source,kotlin]
----
inner class Degree : Block("Degree Block", 10, 5) {
    init {
        border = Border.LINE
    }
}
----

===== Block Alignment

Alignment statements are useful to align a block(source block) referring to another one(target block).
Use the align method and you have to specify the referred block name followed by one or many pairs of two fields  the pairs are separated by a comma.
As for the pair fields, the one in the left is the source block field while the other one is for the target block field.

For Example, let us suppose we have a multiple block Prices with 4 columns,
with column 3 filled with Quantities and Column 4 with Prices, we also have a single block TotalPriceswith two fields totalQuantity and totalPrices, we want these fields to be aligned with the correct fields of the Prices block, so we specify that the totalQuantity field is aligned with the field quantity of the block Prices, same thing for totalPrice field it's aligned with the price field of the block Prices:

*Example*
[source,kotlin]
----
val targetBlock = insertBlock(Prices())

val TotalPrices = block("Total", 1, 1) {

  val totalQuantity = visit(INT(3), position = at(1, 1)) {
    label = "Total"
    help = "Total"
  }
  val totalPrice = visit(INT(7), position = at(1, 2)) {}

  align(targetBlock, totalQuantity to targetBlock.quantity, totalPrice to targetBlock.price)
}
----

===== Block Help

This optional command is used to define the help text for each field of the block. You need to set the value of help property.

*Example*

[source,kotlin]
----
inner class Degree : Block("Degree Block", 10, 5) {
    init {
          border = Border.LINE
          help = "test"
          ...
    }
}
----

===== Block Options
You need to use options function in your block to specify block options. you can find the list of available options in BlockOption class :

 * NOCHART : Disables the chart(grid) rendering of a multiple bloc to make it look like a single block.Only possible on multiple blocks displaying only one row, Besides the fields must be positioned with the AT command.
 * NODETAIL : Disables the positioning of fields and displays the block as a chart (grid), Only possible on multiple blocks, the fields should not be positioned with the AT command.
 * NODELETE :  Prevent the user from removing fields content.
 * NOINSERT :  Prevent the user from inserting data in fields.
 * NOMOVE   :  Prevent the user from moving between records.
 * ACCESS_ON_SKIPPED : Makes the block accessible even if or its fields have SKIPPED access.
 * UPDATE_INDEX : If used, saving a block would delete all its rows and reinsert them one by one, by doing so, you can update the table rows even when you change the index fields without worrying about the "row already exist exception".

[source,kotlin]
----
inner class Degree : Block("Degree Block", 10, 5) {
    init {
          options(BlockOption.NODETAIL)
          ...
    }
}
----

===== Block Tables

When making use of this section, you have to type the function table and enter the table name, assign this function to an variable. This variable will further be used as a shorthand in place of the complete table name in order to access to the table. These names refer to certain tables in the database whereby the first table is the one on which the user will work. The remaining tables are the so-called "look-up tables", i.e tables that are associated with the first one.

*Syntax:*

[source,kotlin]
----
BlockTables:   table(vararg ExposedTables)
----

*Example*

[source,kotlin]
----
inner class School : Block("School", 1, 1) {
  val L = table(Lessons)
  val P = table(Lecturers)
  val R = table(Rooms)
  ...
}
----

The user will make use of these look-up tables as references
when bringing in changes in the principal table.

===== Block Indexes

If you plan to enter one index or more when defining your fields, you also have to define one index text or more which will appear if you make a mistake by entering an indexed data or a data combination twice. This command can be followed by an error message contained in a string.

*Syntax:*

[source,kotlin]
----
BlockIndices:   "index("  message : String  ")" [BlockIndices]*
----

*Example*

[source,kotlin]
----
inner class Degree : Block("Degree", 1, 1) {
  val unique = index(message = "This data already exists")
  ...
}
----
===== Block Commands

Block commands are commands accessible only from the block where they are called. There are Three ways to call block commands:

 * *Calling A Standard Command*

Structure of command:

[source,kotlin]
----
"command (" SimpleItemName  ")" {KOTLIN Code}
----

*Example*
[source,kotlin]
----
command(item = Validate) {
  validate ()
}
----

 *  *Calling The Block Commands With Modes*

Blocks have 3 possible Modes:

 * QUERY  : When querying the database
 * INSERT : When inserting a new row in the database
 * UPDATE : When updating rows in the database

You can combine these modes with the previous block command structure to have more control over your command
Use the mode function inside you command body declaration to set the modes :

*Syntax*
[source,kotlin]
----
"command (" SimpleItemName, [Modes]")" {}

Modes: Mode*
----
This means that the command called is only accessible when the block is in the specified Mode.

*Example*
[source,kotlin]
----
command(item = Validate, Mode.UPDATE, Mode.QUERY) {
  validate ()
}
----

 * *Calling The Block Commands With Modes And An Access Modifier*

in Galite, a field can have different access types or modifiers, here is the definition of the four available access modifiers listed by ascending level.

 * HIDDEN : HIDDEN field are invisible in the form, they are used to store hidden operations and database joins.
 * SKIPPED : SKIPPED fields are read only fields, you can read the value but you can't modify it.
 * VISIT : fields with this access type are accessible, can be modified but not necessary.
 * MUSTFILL : MUSTFILL fields are accessible fields that the user must fill with a value.

In the block command section, you can set the highest access level for the block fields according to the mode in wich the block would be ording to the mode in which the block would be.

*Example*
[source,kotlin]
----
blockVisibility(Access.SKIPPED, Modes.QUERY, Modes.UPDATE)
blockVisibility(Access.HIDDEN, Modes.UPDATE)
blockVisibility(Access.VISIT, Modes.QUERY)
----

In the first example, all fields in the block will be either SKIPPED or HIDDEN in the query and update modes and can neither be MUSTFILL nor VISIT.
For the second example, all the fields in the block will be HIDDEN when the block is in update mode.
In the last example, all the fields in the block will be either VISIT, SKIPPED or HIDDEN in the query mode and can not be MUSTFILL.

===== Block Triggers

The block triggers are the same as form triggers on the block level. There are actually 20 block triggers you can use to execute actions once they are fired.

*Syntax*
[source,kotlin]
----
 BlocTrigger: "trigger(" TriggerAction : BlocEventList ")"

 BlocEventList: BlockEvent [,BlockEvent]*
----

Concerning the trigger action, which is the action to execute when the trigger is activated they can by :
 ** {KOTLIN code}


Here is a list of all available block triggers or block events in Galite.

 ** PREQRY  : executed before querying the database
 ** POSTQRY : executed after querying the database
 ** PREDEL  : executed before a row is deleted
 ** POSTDEL : executed after a row is deleted
 ** PREINS  : executed before a row is inserted
 ** POSTINS : executed after a row is inserted
 ** PREUPD  : executed before a row is updated
 ** POSTUPD : executed after a row is updated
 ** PRESAVE : executed before saving a row
 ** PREREC  : executed upon record entry
 ** POSTREC : executed upon record exit
 ** PREBLK  : executed upon block entry
 ** POSTBLK : executed upon block exit
 ** VALBLK  : executed upon block validation
 ** VALREC  : executed upon record validation
 ** DEFAULT : is executed when the block is in the InsertMode. This trigger becomes active when the user presses the key F4. It will then enable the system to load standard values which will be proposed to the user if he wishes to enter new data.
 ** INIT    : executed upon block initialization
 ** RESET   : executed upon Reset command (ResetForm)
 ** CHANGED : a special trigger that returns a boolean value of wether the block have been changed or not, you can use it to bypass the system control for changes this way :
----
 trigger(CHANGED) {
   return false;
 }
----

 ** ACCESS  : defines whether a block can or not be accessed, it must always return a boolean value

----
  trigger(ACCESS) {
    return Block.getMode() == MOD_QUERY
    // Tests if the block is in query mode,
    this block is only accessible on query mode
  }
----

*Examples*
[source,kotlin]
----
object Degree : Block("Degree block", 10, 5) {

  trigger(PREBLK, INIT) {
   Kotlin-Code
  }

  trigger(PREINS) {
   println("Inserting date");
   ...
  }
  ...
}
----

===== Block Fields Declaration

In this section, all you have to do is to write at least on block field definition that begins with an access modifier and ends with brace "}", you can enter as much fields as you may need
following the field definition we saw in the previous chapter.

*Examples*
[source,kotlin]
----
val name = visit(domain = STRING(25), position = at(1, 2)) {
      label = "Last name"
      help = "The client name"
      columns(c.name)
}
----

==== Creating Forms 

There are actually two types of forms in Galite, normal forms and BLOC INSERT forms which are special forms containing blocks that you may insert in other forms. +
A form begins always with FORM and ends with END FORM, while a BLOC INSERT form begins with BLOC INSERT and ends with END INSERT.

In Galite to create a form you need to extend from this list off classes :

 ** Form  : Represents a form.
 ** ReportSelectionForm : Represents a report selection form.
 ** DictionaryForm : Represents a dictionary form.

When creating a form, you will have to include the block and the field definitions. Moreover, you will have to define the menus as well as the different commands. Finally, you can also define some form triggers. Concretely, the structure is the following:

*Syntax:*
[source,kotlin]
----
FormDef :
          class FormSample: Form("title ="  formTitle : String, ["locale ="  formLocalization : String])
          {
              [MenuDefinition]
              [ActorDefinition] [TypeDefinition]
              [CommandDefinition] [InsertDefinition]

              [FormCommands] [FormsTriggers] [BlocksDefinition]
          }
----

===== Form Localization

This is an optional step in which you may define the language of your forms menus and messages, the latter have to be defined in xml files.

*Syntax*
[source,kotlin]
----
"Form(title =" formTitle : String, "locale =" formLocalization : String")"
----
*Example:*
[source,kotlin]
----
class LecturersForm : Form(title = "Form", locale = Locale.UK) {}
----

===== Form Title

Every form have can have a title (optional).

*Syntax*
[source,kotlin]
----
"Form(title =" formTitle : String")"
----

*Example*

[source,kotlin]
----
class LecturersForm : Form(title = "Lecturers List", locale = Locale.UK) {}
----

===== Menus Definition

Defining a menu means adding an entry to the menu bar in the top of the form, you can add actors to this menu later by specifying the menu name in the actor definition.

*Syntax:*

[source,kotlin]
----  
MenuDefinition: "menu (" label : String ")"
----

*Example*

[source,kotlin]
----
class ListLecturersForm : ReportSelectionForm(title = "List of the Lecturers", locale = Locale.UK) {
  val file = menu("file")
  ...
}
----

===== Actors Definition

An Actor is an item to be linked with a command, if its ICON is specified, it will appear in the icon_toolbar located under the menu bar, otherwise, it will only be accecible from the menu bar.
ICON and KEY are optional, the KEY being the keyboard shortcut to assign to the actor.


*Syntax:*

[source,kotlin]
----
ActorDefinition:  "actor"(
                    "menu" = SimpleName,
                    "label" = label : String,
                    "help" = helpText : String,
                  ) {
                    [key = key  : String]
                    [icon = icon : Icon]
                  }
----

*Example*

[source,kotlin]
----

class ListLecturersForm : ReportSelectionForm(title = "List of the Lecturers", locale = Locale.UK) {
  val file = menu("file")
  val cut = actor(
    menu = file,
    label = "cut",
    help = "cut element",
  ) {
    key = Key.F2          // key is optional here
    icon = Icon.CUT       // icon is optional here
  }
  ....
}
----

===== Types Definition

After having defined your menus and actor, you can enter different field types definitions based on the standard field types or code field types, you can also use SELECT commands
to customize these new types.

*Example*

[source,kotlin]
----
class ListLecturersForm : ReportSelectionForm("") {

    object Days: CodeDomain<Int>() {
      init {
        "Sunday" keyOf 1
        "Monday" keyOf 2
        "Tuesday" keyOf 3
        "Wednesday" keyOf 4
        "Thursday" keyOf 5
        "Friday" keyOf 6
        "Saturday" keyOf 7
      }
    }

    object CurrentDegree : ListDomain<String>(20) {
      override val table = query(Degree.selectAll())

      init {
        "Symbol" keyOf Degree.Symbol
        "Description" keyOf Degree.Description
      }
    }
}
----

===== Commands Definition

In this section you may want to define new commands, to do so, all you need is an already defined Actor from which you will call the command in order to execute an Action on the form.
every command have a effective ray of action (VField, VBlock, VForm)

 * Simply writing the body of the action using the  ACTION command, the parameters are optional and can be VField, VBlock, VForm.

Command Defined in this section can be form level commands, block level commands or field level commands, this will depend on the action called by the command and where the command is actualy called.

*Syntax*
[source,kotlin]
----
cmdDef  : "command (" SimpleItemName  ")" { commandBody }

commandBody: { KOTLIN statements }
----

*Example*
Writing the action's body :

[source,kotlin]
----
command(item = PrintBlock) {
  blockName.validate()
  blockName.getForm().close(VForm.CDE-Validate)
}
----

After the different definitions we have made (types, menus, actors,commands), we need to begin the declaration of our form.Here, we will set up the structure and the behaviour of the form throw 4 sections :

 * Form Options
 * Form Commands
 * Form Triggers
 * Blocks

===== Form Commands Declaration

There still one more think to know about form command declaration, in fact, you can also control the accessibility to a command by the Mode of the form.+
A form have 3 possible Modes :

 * QUERY  : When inquiring the database
 * INSERT : When inserting a row in the database
 * UPDATE : When updating a row in the database

The Syntax to use command with modes is the following :

*Syntax*
[source,kotlin]
----
"command (" SimpleItemName, Modes  ")" {}

Modes: Mode*
----
This means that the command called is only accessible when the block is in the specified Mode.

*Example*
[source,kotlin]
----
command(item = Validate, Mode.UPDATE, Mode.QUERY) {
  validate ()
}
----

===== Form Triggers Definition
Form Triggers are special events that once switched on you can execute a set of actions defined by the following syntax :

*Syntax*
----
FormTrigger  :  "trigger(" TriggerAction : FormEventList ")"
FormEventList:  FormEvent [,FormEvent]*
----

Galite actually defines 6 Form Triggers or Form Events :

 * INIT      : executed when initializing the form and before the PREFORM Trigger, also executed at ResetForm command
 * PREFORM   : executed before the form is displayed and after the INIT Trigger, not executed at ResetForm command
 * POSTFORM  : executed when closing the form
 * QUITFORM  : actually not available
 * RESET     : executed upon ResetForm command
 * CHANGED   : a special trigger that returns a boolean value of whether the form have been changed or not, you can use it to bypass the system control for changes this way :
----
val postform = trigger(POSTFORM) {
  println("post form trigger works")
}
----

*Examples*
----
val preform = trigger(INIT) {
    println("init form trigger works")
}

val initialisation = trigger(INIT, PREFORM) {
    //KOTLIN statements
}
----

===== Form Pages 

You can create Pages in your form using the page function after the trigger declaration section,this is optional and will create a Tab for each page you create under the form's toolbar.
You can put as much blocks you want in each page, the same goes for form without pages.

*Example*
----
val p1 = page("Page1")
----
